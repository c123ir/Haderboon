بسیار عالی! این یک درخواست کلیدی و مهم است. یک سناریوی کامل، به شما کمک می‌کند تا نحوه تعامل با این دستیار هوشمند را به صورت عملی درک کنید و اطمینان حاصل کنید که نیازهای شما به خوبی برآورده می‌شوند. همچنین، راهکار همگام‌سازی دائم بین کد و داده‌های ایجنت از اهمیت بالایی برخوردار است و به آن به تفصیل خواهم پرداخت.

در ادامه، یک سناریوی کامل را در قالب یک سند مستند شده برای شما ارائه می‌دهم:

---

## سناریوی استفاده از ایجنت دستیار مستندساز هوشمند: از ایده تا مستندسازی نهایی

### ۱. مقدمه

این سناریو، یک نمونه گام به گام از چگونگی استفاده یک برنامه‌نویس از "ایجنت دستیار مستندساز هوشمند" را برای توسعه یک پروژه نرم‌افزاری جدید، از مرحله ایده‌پردازی اولیه تا کدنویسی و مستندسازی نهایی، شرح می‌دهد. هدف اصلی، نمایش چگونگی نقش این ایجنت به عنوان یک مشاور هوشمند، مستندساز خودکار و ابزار همگام‌سازی مداوم با وضعیت واقعی پروژه است.

### ۲. شخصیت فرضی

**نام:** سارا
**شغل:** برنامه‌نویس فول‌استک
**مشکل اصلی:** سارا پروژه‌های زیادی را با کمک هوش مصنوعی شروع کرده، اما به دلیل عدم مستندسازی کافی و مشکل در همگام نگه داشتن مستندات با کد واقعی، اغلب در میانه راه "گیر می‌کند" و پروژه‌هایش به هم می‌ریزد.

### ۳. سناریوی عملیاتی

**هدف سارا:** توسعه یک "پلتفرم مدیریت کتابخانه شخصی آنلاین" که به کاربران اجازه می‌دهد کتاب‌های خود را ثبت، دسته‌بندی و به اشتراک بگذارند.

#### ۳.۱. شروع پروژه در ایجنت و ایده‌پردازی اولیه

1.  **ایجاد پروژه در ایجنت:**
    *   سارا وارد رابط کاربری "ایجنت دستیار مستندساز" می‌شود.
    *   او روی دکمه "ایجاد پروژه جدید" کلیک می‌کند و نام پروژه را "My Personal Library" وارد می‌کند.
    *   در بخش "اهداف اولیه"، او می‌نویسد: "ایجاد یک پلتفرم آنلاین برای مدیریت کتاب‌های شخصی، شامل افزودن، ویرایش، دسته‌بندی و اشتراک‌گذاری."

2.  **تعامل برای ایده‌پردازی و طراحی (نقش مشاور):**
    *   سارا در بخش چت ایجنت می‌نویسد: "ایجنت، می‌خواهم درباره معماری اولیه این پروژه صحبت کنم. به نظرت چه بخش‌های اصلی نیاز داریم؟"
    *   **ایجنت:** "سلام سارا! پروژه 'My Personal Library' ایده بسیار خوبی است. برای شروع، بخش‌های اصلی زیر را پیشنهاد می‌کنم:
        *   **احراز هویت کاربران (User Authentication):** ثبت نام، ورود، مدیریت پروفایل.
        *   **مدیریت کتاب‌ها (Book Management):** افزودن، ویرایش، حذف، مشاهده کتاب‌ها.
        *   **دسته‌بندی (Categorization):** برچسب‌گذاری، ایجاد مجموعه‌ها.
        *   **اشتراک‌گذاری (Sharing):** قابلیت به اشتراک گذاشتن کتاب‌ها با دیگران.
        *   **جستجو و فیلتر:** جستجو و یافتن کتاب‌ها بر اساس عنوان، نویسنده، ژانر و ...
        *   **API Gateway:** برای ارتباط امن و استاندارد بین فرانت‌اند و بک‌اند.
        *   **پایگاه داده:** برای ذخیره تمام اطلاعات.
        *   کدام بخش را ترجیح می‌دهید ابتدا روی آن تمرکز کنیم؟"
    *   سارا: "فکر می‌کنم اولویت با "احراز هویت کاربران" و "مدیریت کتاب‌ها" باشد. معماری کلی برای بک‌اند و فرانت‌اند چطور؟"
    *   **ایجنت:** "برای بک‌اند، Node.js با Express و Prisma (به همراه PostgreSQL) انتخاب‌های بسیار مناسبی هستند. برای فرانت‌اند، React با TypeScript و Tailwind CSS به شما کمک می‌کند UI قدرتمند و زیبایی بسازید. این استک تکنولوژی مدرن و قدرتمندی است. موافقید؟"
    *   سارا: "بله، کاملاً موافقم. لطفاً یک جمع‌بندی از این بحث و بخش‌های اصلی را مستند کن."
    *   **ایجنت:** (جمع‌بندی بحث را به صورت یک سند "معماری اولیه پروژه" در بخش مستندات پروژه ذخیره می‌کند. این سند شامل بخش‌های اصلی، فناوری‌های پیشنهادی، و تصمیمات اولیه می‌شود.)

#### ۳.۲. شروع کدنویسی و اولین همگام‌سازی (مستندسازی اولیه)

1.  **کدنویسی اولیه در IDE:**
    *   سارا IDE خود (مثلاً Cursor AI) را باز می‌کند.
    *   او پروژه `My Personal Library` را در IDE ایجاد می‌کند و ساختار اولیه بک‌اند و فرانت‌اند (فایل‌های `package.json`, `tsconfig.json`, `App.tsx`, `server.ts` و ... را) را به همراه تنظیمات Prisma و PostgreSQL ایجاد می‌کند (بدون هیچ منطق پیچیده‌ای، فقط ساختار پایه).

2.  **همگام‌سازی اولیه با ایجنت:**
    *   سارا تمام تغییرات را در Git `commit` و `push` می‌کند.
    *   **راهکار همگام‌سازی:** ایجنت دستیار، که به مخزن Git پروژه `My Personal Library` متصل است، تشخیص می‌دهد که `commit` جدیدی انجام شده است. ایجنت به صورت خودکار یا با یک اعلان (مثلاً "تغییرات جدید در مخزن شما شناسایی شد. آیا مایلید پروژه را اسکن و مستندات را به‌روزرسانی کنم؟")، شروع به اسکن می‌کند.
    *   ایجنت کل ساختار پروژه، فایل‌های موجود، وابستگی‌ها (مانند `express`, `react`, `prisma`) را تحلیل می‌کند.
    *   **ایجنت:** "سارا، من ساختار اولیه پروژه شما را شناسایی کردم. یک پیش‌نویس از مستندات پایه پروژه، شامل دایرکتوری‌ها، وابستگی‌ها، و تنظیمات اولیه، در بخش 'مستندات' پروژه شما ایجاد شد. لطفاً آن را بررسی کنید و هر بخشی که نیاز به توضیح بیشتر دارد را بپرسید."

#### ۳.۳. توسعه یک فیچر جدید (احراز هویت) و همگام‌سازی مداوم

1.  **برنامه‌ریزی فیچر با ایجنت:**
    *   سارا: "ایجنت، می‌خواهم ماژول احراز هویت را شروع کنم. نیاز به ثبت نام و ورود دارم. لطفا برای بخش بک‌اند، یک پرامپت کامل برای پیاده‌سازی کنترلر `authController.ts` با استفاده از `bcryptjs` برای هش کردن پسورد و `jsonwebtoken` برای تولید توکن JWT آماده کن."
    *   **ایجنت:** "بسیار خوب. پرامپت زیر را می‌توانید مستقیماً در ابزار کدنویس AI خود (مثل Cursor AI) استفاده کنید. این پرامپت شامل زمینه پروژه شما، هدف، و محدودیت‌های فنی است:"
        ```
        '''
        پروژه: My Personal Library (بک‌اند Node.js/Express با TypeScript و Prisma)
        فایل هدف: backend/src/controllers/authController.ts

        هدف: یک فایل TypeScript به نام 'authController.ts' ایجاد کن که شامل دو تابع 'registerUser' و 'loginUser' باشد.

        جزئیات و محدودیت‌ها:
        1.  **تابع 'registerUser':**
            *   ورودی: `username`, `email`, `password` (از `req.body`).
            *   بررسی کند که آیا کاربر با ایمیل یا نام کاربری موجود است.
            *   پسورد را با `bcryptjs` هش کند (با salt rounds 10).
            *   کاربر جدید را با Prisma در جدول 'User' (که از قبل در schema.prisma تعریف شده) ذخیره کند.
            *   یک JSON Web Token (JWT) با `userId` به عنوان Payload و `process.env.JWT_SECRET` به عنوان راز (secret) تولید کند.
            *   JWT را به عنوان یک کوکی HTTP-Only و یک پاسخ JSON به کاربر برگرداند.
            *   خطاهای مناسب را مدیریت کند (مثلاً کاربر تکراری، خطای سرور).
        2.  **تابع 'loginUser':**
            *   ورودی: `email`, `password` (از `req.body`).
            *   کاربر را بر اساس ایمیل از دیتابیس پیدا کند.
            *   پسورد ورودی را با پسورد هش شده ذخیره شده توسط `bcryptjs.compare` مقایسه کند.
            *   اگر اعتبار سنجی موفق بود، یک JWT جدید (مانند تابع 'registerUser') تولید کرده و برگرداند.
            *   خطاهای مناسب را مدیریت کند (مثلاً اعتبار سنجی ناموفق، کاربر یافت نشد).
        3.  **Imports:** `Request`, `Response`, `NextFunction` از `express`، `bcryptjs`، `jsonwebtoken`، `prisma` از `../utils/prismaClient`.
        4.  **نوع بازگشتی:** هر تابع باید `Promise<Response>` را برگرداند.
        5.  **کامنت‌گذاری:** تمام قسمت‌های کد را با کامنت‌های فارسی توضیح بده.
        '''
        ```
    *   سارا پرامپت را کپی کرده و در Cursor AI قرار می‌دهد. Cursor AI کد `authController.ts` را تولید می‌کند.
    *   سارا کد را بررسی و در پروژه خود ذخیره می‌کند.

2.  **همگام‌سازی مداوم (بدون وقفه):**
    *   سارا فایل `authController.ts` و سپس `authRoutes.ts` (که از این کنترلر استفاده می‌کند) را ایجاد و ویرایش می‌کند.
    *   او تغییرات را در Git `commit` و `push` می‌کند.
    *   **راهکار همگام‌سازی (دوباره):** ایجنت به صورت خودکار تغییرات جدید را شناسایی می‌کند.
    *   **ایجنت:** "تغییرات جدید در ماژول احراز هویت شناسایی شد. من `authController.ts` و `authRoutes.ts` را تحلیل کردم. یک پیش‌نویس از مستندات API مربوط به ثبت نام و ورود، به همراه توضیح توابع کنترلر و نحوه احراز هویت، در بخش 'مستندات' پروژه شما به‌روزرسانی شد."

#### ۳.۴. بررسی داشبورد پیشرفت

*   سارا در هر زمان می‌تواند به "داشبورد پروژه" در ایجنت خود مراجعه کند.
*   **داشبورد نمایش می‌دهد:**
    *   **پیشرفت کلی پروژه:** `20%` (مثلاً بر اساس تعداد ماژول‌های کلیدی که در MVP تعریف شده و میزان مستندسازی آن‌ها).
    *   **پیشرفت ماژول‌ها:**
        *   **احراز هویت کاربران:** `60%` (کنترلرها و مسیرها آماده‌اند، نیاز به UI فرانت‌اند).
        *   **مدیریت کتاب‌ها:** `0%`
        *   **مدیریت مستندات:** `10%` (ساختار اولیه و تعریف مدل).
        *   **چت هوشمند:** `0%`
    *   **فایل‌های اخیراً مستند شده/تحلیل شده:** `authController.ts`, `authRoutes.ts`, `schema.prisma`.
    *   **نقاط نیازمند توجه:** "UI برای احراز هویت (فرانت‌اند) باید پیاده‌سازی شود. تست‌های واحد برای `authController` نیز نیاز است."
*   **مکانیسم محاسبه پیشرفت:** ایجنت درصد پیشرفت را بر اساس موارد زیر محاسبه می‌کند:
    *   **کامل بودن مستندات:** آیا تمام بخش‌های کد تحلیل و مستند شده‌اند؟
    *   **پوشش فیچرها:** چند درصد از فیچرهای تعریف شده در MVP (مثلاً ثبت نام، ورود) به صورت کامل کدنویسی و مستند شده‌اند؟
    *   **پیچیدگی تخمینی:** ایجنت می‌تواند پیچیدگی بخش‌های مختلف را تخمین زده و بر اساس آن، وزن‌دهی به پیشرفت کند.
    *   **وضعیت تست‌ها (در آینده):** اگر ایجنت به گزارش‌های تست دسترسی داشته باشد، می‌تواند پوشش تست را نیز در درصد پیشرفت لحاظ کند.

#### ۳.۵. حل یک مشکل (اشکال‌زدایی با ایجنت)

1.  **وقوع مشکل:** سارا هنگام تلاش برای ورود، با خطای "Invalid Credentials" مواجه می‌شود، در حالی که مطمئن است اطلاعاتش درست است.
2.  **درخواست کمک از ایجنت:**
    *   سارا به بخش چت ایجنت می‌رود و می‌نویسد: "من در لاگین مشکل دارم. همیشه 'Invalid Credentials' می‌گیرم. این هم کد `loginUser` در `authController.ts` است:"
        ```typescript
        // ... (بخشی از کد loginUser که سارا کپی کرده)
        ```
    *   **ایجنت:** (کد را تحلیل می‌کند، با دیتابیس اسکیمای `User` مقایسه می‌کند، و ممکن است حتی لاگ‌های خطای بک‌اند را بررسی کند اگر به آن‌ها دسترسی داشته باشد.)
        "سارا، کد `loginUser` شما را بررسی کردم. به نظر می‌رسد مشکلی در مقایسه پسورد وجود دارد. لطفاً مطمئن شوید که `bcryptjs.compare` به درستی استفاده شده و ترتیب آرگومان‌ها صحیح است (`password` ورودی ابتدا، سپس `user.passwordHash` از دیتابیس). همچنین، بررسی کنید که آیا در زمان ثبت نام، پسورد به درستی هش و ذخیره شده است. اگر همچنان مشکل دارید، یک `console.log` موقت قبل از `bcryptjs.compare` بگذارید تا مقادیر `password` و `user.passwordHash` را ببینید."
    *   سارا: "حق با تو بود! در زمان ثبت نام، به اشتباه پسورد را هش نمی‌کردم. الان درست شد."
    *   **ایجنت:** (راه حل را به عنوان یک "مشکل حل شده" در بخش مستندات ثبت می‌کند و آن را به بخش "اشکالات رایج" یا "نکات توسعه" اضافه می‌کند.)

#### ۳.۶. مستندسازی نهایی و مرور پروژه

*   با نزدیک شدن پروژه به اتمام، سارا می‌تواند از ایجنت بخواهد تا یک "گزارش نهایی مستندات پروژه" را تولید کند.
*   **ایجنت:** تمام مستندات تولید شده (معماری، APIها، ماژول‌ها، توابع، تصمیمات طراحی، مشکلات حل شده) را گردآوری، سازماندهی و به صورت یک سند واحد (مثلاً در فرمت Markdown یا PDF) ارائه می‌دهد.
*   سارا می‌تواند این سند را برای تیم یا مشتریان خود به اشتراک بگذارد و با اطمینان از کامل و به‌روز بودن آن، از کیفیت کار خود دفاع کند.

### ۴. راهکار حفظ همگام‌سازی (Code-Agent Sync)

مهم‌ترین چالش در این سناریو، اطمینان از عدم وجود **هیچ گونه اختلاف** بین وضعیت واقعی کد در حال توسعه و داده‌های ایجنت است. راهکار ما برای دستیابی به این همگام‌سازی مداوم و دقیق به شرح زیر است:

1.  **یکپارچه‌سازی عمیق با Git/Version Control System (VCS):**
    *   **اتصال مستقیم:** ایجنت به مخزن Git پروژه شما (مثلاً در GitHub, GitLab, Bitbucket) متصل می‌شود.
    *   **وب‌هوک‌ها (Webhooks):** در تنظیمات مخزن Git، وب‌هوک‌هایی پیکربندی می‌شوند که با هر `push` یا `merge` جدید به ایجنت اطلاع می‌دهند. این به ایجنت امکان می‌دهد تا بلافاصله از تغییرات کد مطلع شود.
    *   **تحلیل تفاوت (Diff Analysis):** ایجنت می‌تواند تفاوت‌ها (diffs) بین نسخه‌های کد را تحلیل کند (مشابه کاری که Git انجام می‌دهد). این به آن اجازه می‌دهد تا بفهمد کدام فایل‌ها تغییر کرده‌اند، چه خطوطی اضافه، حذف یا ویرایش شده‌اند.
    *   **نقشه فایل (File Map) با هشینگ (Hashing):** ایجنت یک نقشه (map) از تمام فایل‌های پروژه و محتوای آن‌ها (با استفاده از هش‌های SHA256) را نگهداری می‌کند. با هر همگام‌سازی، ایجنت هش‌های جدید فایل‌ها را با هش‌های ذخیره شده مقایسه می‌کند. هر فایل با هش متفاوت، به عنوان "تغییر یافته" شناسایی می‌شود و به صف تحلیل اضافه می‌گردد.

2.  **اسکن مداوم و On-Demand:**
    *   **اسکن دوره‌ای (Periodic Scan):** ایجنت می‌تواند در فواصل زمانی مشخص (مثلاً هر ۳۰ دقیقه، یا ساعتی) یک اسکن کامل یا جزئی از پروژه (بر اساس تغییرات Git) انجام دهد تا از آخرین وضعیت اطمینان حاصل شود.
    *   **همگام‌سازی دستی/اجباری (Manual/Forced Sync):** کاربر همیشه گزینه‌ای در رابط کاربری ایجنت یا از طریق یک ابزار CLI (مثلاً `ai-doc sync --force`) دارد تا ایجنت را مجبور به اسکن و همگام‌سازی کامل پروژه کند. این برای مواقعی که کاربر تغییرات زیادی بدون `commit` داشته یا می‌خواهد از صحت همگام‌سازی اطمینان یابد، مفید است.

3.  **ابزارهای کمکی و افزونه‌های IDE (فازهای بعدی توسعه):**
    *   **CLI Tool:** یک ابزار خط فرمان ساده (مانند `ai-doc add <file_path>`, `ai-doc update <file_path>`, `ai-doc analyze <file_path>`) که به کاربر اجازه می‌دهد به صورت مستقیم تغییرات فایل‌های خاصی را به ایجنت گزارش دهد، حتی قبل از `commit` به Git.
    *   **افزونه‌های IDE:** در آینده، می‌توان افزونه‌هایی برای IDE‌های محبوب (VS Code, Cursor AI) توسعه داد. این افزونه‌ها می‌توانند تغییرات فایل را در لحظه تشخیص دهند و با ایجنت ارتباط برقرار کنند. مثلاً، وقتی یک تابع جدید می‌نویسید، افزونه می‌تواند یک پیشنهاد (Pop-up) از ایجنت نمایش دهد: "یک تابع جدید شناسایی شد. آیا مایلید مستندات آن را ایجاد کنم؟" این قابلیت، همگام‌سازی را در سطح میکروسکوپی و تعاملی فراهم می‌کند.

4.  **تگ‌گذاری و ردیابی داخلی (Internal Tagging & Tracking):**
    *   ایجنت می‌تواند به هر بخش مستندات تولید شده، یک شناسه منحصر به فرد داخلی و لینک مستقیم به خطوط کد مربوطه در Git اضافه کند. این ردیابی داخلی به ایجنت کمک می‌کند تا با تغییر یا حذف کد، مستندات مرتبط را شناسایی و به‌روزرسانی یا بایگانی کند.

با ترکیب این رویکردها، ما اطمینان حاصل می‌کنیم که "ایجنت دستیار مستندساز" همیشه یک "تصویر زنده و دقیق" از پروژه شما در اختیار دارد و هرگز از وضعیت واقعی کد عقب نخواهد ماند. این تعامل پویا، مشکل شما را در "استپ شدن" در اواسط پروژه و "بهم‌ریختگی پروژه توسط هوش مصنوعی" به طور کامل حل خواهد کرد.

---

امیدوارم این سناریو به شما در تجسم عملکرد ایجنت و اطمینان از جامعیت آن کمک کند. لطفاً هر سوال یا نکته دیگری که به ذهنتان می‌رسد را مطرح کنید.